# 具身智能笔记 01
## 具身智能基础，PID控制算法，机器人运动学基础
### 1、具身智能基础
（1）具身智能 = 行动的身体（感知） + 智能的大脑（学习）

（2）具身智能关键三要素：

    -身体（Body）：物理形态智能体。
                  e.g. 感知结构：摄像头、激光雷达等。
                       行动结构：电机、机械臂、轮子等。

    -大脑（Brain）：算法核心，处理来自传感器的数据。
                   思考、决策并向执行器发出指令。
                   通常涉及：深度学习、强化学习、LLM等。

    -环境（Environment）：智能体所处的物理世界，在这里进行感知、交互、学习。

    流程：

    感知（Perception） ——> 决策（Policy） ——> 执行（Action） ——> 新一轮感知 ——> ......

（3）技术堆栈

    -硬件层（The Body）：驱动、传感、计算平台。

    -软件/系统层（The NervousSystem）：操作系统、仿真、通信。

    -算法/认知层（The Brain）：感知、决策、规划、控制。

    -应用层（The Purpose）：工业、家庭、特种作业、医疗。

### 2、PID控制算法

（1）PID中的P是什么？

P（Proportional）：P算法。

K_p：比例系数。

    e.g.
    
    以无人机控制为例，要使无人机悬停在高度H。无人机当前高度h与目标高度H之间的误差 H-h 设为error。
    
    假设无人机的升力P_out与误差error呈线性关系（此处仅做假设，实际情况示情况而定）：
                              
                                    P_out = K_p * error

    error 为正值，H-h > 0，表示无人机还没有飞到目标高度，此时升力 P_out 也为正值，表示正在提供向上的升力。
    error 为负值，H-h < 0，表示无人机超过了目标高度，此时升力 P_out 为负值，表示正在提供向下的拉力。

    当无人机当前高度h与目标高度H之间差距越大，即error绝对值越大，则需要的升力或拉力也越大。P即表示升力和误差之间的比例关系。

    升力产生变化时，如果K_p越大，误差 error（error=F/K_p） 越小，即无人机当前高度h与目标高度H之间的差距迅速变小，
    此时控制系统响应速度快，可以迅速减少误差。

    由于比例系数 Kp 越大，系统对“当前误差”的激烈的反应让它更快地冲向目标，当无人机越来越接近目标高度时，
    因为惯性（系统的滞后和储能特性），它很容易“刹不住车”，冲过头，然后又在反方向上进行同样激烈的纠正，从而导致震荡。
    P算法中这种震荡导致的系统不稳定问题，可以通过PID中的D解决。
    
（2）PID中的D是什么？

D（Derivative）：预测误差的变化趋势，从而提前进行调整，以此来解决P算法产生的系统不稳定问题，提高系统的响应速度和稳定性。

K_d：微分系数。

    e.g.

    依旧以无人机控制为例，对误差距离求微分本质上是求误差的变化速度：

                             d(error)/dt = v

    此时微分项的输出：

                      D_out = K_d * [d（error) / dt]

    那么可以分两种情况进行讨论，无人机马上飞到目标高度，和无人机由于惯性已经飞过目标高度两种情况进行讨论：

    情况一：无人机马上要飞到目标高度时

    假设现在无人机的误差error，H-h = 0.1 m
    假设上一秒无人机的误差error，H-h = 0.2 m
    
    误差变化 d(error) = 0.1 - 0.2 = -0.1，为负数。意味着误差正在快速减小。

    D算法的“思考”： “误差正在飞速减小，照这个速度，马上就会变成零，然后由于惯性肯定会变成负误差（冲过头）。
                   我必须现在就行动，提前刹车！”
    D算法的行动： D_out = K_d * (-0.1)。由于 K_d 是正数，所以 D_out 是一个负值。
                 此时，P项可能还在提供一点向上的升力（因为还有+0.1米的误差），
                 但D项已经提供了一个强大的向下拉力（负值）来抵消P项。
                 这相当于在到达目标之前就提前收油门并轻点刹车，从而极大地减少了超调量，避免了冲过头。

    情况二：无人机由于惯性已经冲过头后开始向下飞回目标位置

    假设现在无人机的误差error，H-h = -0.1 m
    假设上一秒无人机的误差error，H-h = -0.2 m

    误差变化 d(error) = -0.1 - (-0.2 )= 0.1，为正数。
    D项的“思考”： 负误差的绝对值在变小（即无人机正在从上向下靠近目标高度）。我应该向上拉住它避免它飞过头。
    D项的行动： D_out = K_d * 0.1，是一个负值。 
               此时P项的输出是负的（因为误差为负，要求向下飞），而D项的正输出会削弱总的向下控制力，
               相当于在向下俯冲时“拉了一把”，防止它掉得太猛，从而抑制了反向的超调。


（3）PID中的I是什么？

I（Integral）：引入I算法来解决误差永远不会为0的问题（后续进行解释）。

K_i：积分系数。

    e.g.
    依旧以无人机控制为例，当无人机向上飞接近目标高度时，经过震荡等过程，无人机最终会悬停在一个高度，但这个高度永远不可能是目标高度。
    无人机最终悬停的高度h与目标高度H之间一定会存在一个误差。
    这是因为，如果无人机真的能够悬停在目标高度，那么此时：
    
                      H-h = 0，即 error=0，
                      
    那么无人机的升力：
    
                      P_out = K_p * 0 = 0

    但是无人机本身有重量，升力为0，无人机自身的重力会把无人机拉下去，
    所以无人机此时不可能能够悬停在目标高度。

    无人机悬停的高度 h 必须和目标高度 H 之间有一定的误差，只有当误差 error 不为0时，无人机才能有升力，升力和重力才可能平衡。
    在这种情况下，无人机永远无法达到目标高度。

    为了解决这个问题，引入I算法，即引入积分项，对误差进行累积。

    积分项的输出：
    
                     I_out = K_i * ∫(error * dt)

    这意味着，只要这个误差不消失，积分项就会不断地、一点一点地累加这个误差值。I_out 会随着时间越来越大。

    现在的总控制输出是 U = P_out + I_out 。
    即使某时刻 P_out 已经稳定在 Kp * error，I_out 也在不断增长。
    这个不断增长的 I_out 提供了额外的升力，开始将无人机往上推。

    无人机开始上升，误差开始减小。
    随着误差减小，P项的输出会略微下降，但I项的输出由于其累积效应，仍然很强劲。
    最终，无人机被精确地推到目标高度。

    在目标高度，误差=0。此时 P_out = 0。
    但是，I_out 并不会立刻归零，它累积了一个历史值，在无人机被推进的过程到到达目标高度的过程中，这个值恰好等于所需的那个额外的、持续的控制力。

综上，经过PID控制算法，总控制输出：

              U = P_out + I_out + D_out
              
                = K_p * error + K_d * [d（error) / dt] + K_i * ∫(error * dt)


PID控制算法实现：

``` 
class PID:
    # pid的初始化赋值
    def __init__(self, Kp, Ki, Kd, setpoint=0, sample_time=0.01):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint
        self.sample_time = sample_time
 
        self.prev_error = 0
        self.integral = 0

    # pid的cal_process
    def update(self, measured_value):
        error = self.setpoint - measured_value # 计算误差
        self.integral += error * self.sample_time # 积分
        derivative = (error - self.prev_error) / self. sample_time # 微分
 
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative # 计算控制输入
        self.prev_error = error # 保存误差
 
        return output
 

pid = PID(Kp=1.0, Ki=0.1, Kd=0.01, setpoint=100)
measured_value = 90  # 假设的当前测量值
control_input = pid.update(measured_value)
 
print(f"Control Input: {control_input}")

```
                      



    
        
